«REM»
Copyright 2017 Alessio Rossotti
This file is part of it.polimi.mobilecodegenerator.

it.polimi.mobilecodegenerator is free software: 
you can redistribute it and/or modify it under the terms of the 
GNU General Public License as published by the Free Software Foundation, 
either version 3 of the License, or (at your option) any later version.

it.polimi.mobilecodegenerator is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
See the GNU General Public License for more details.You should have received a copy of the GNU General Public License
along with it.polimi.mobilecodegenerator. If not, see <http://www.gnu.org/licenses/>
«ENDREM»

«IMPORT metamodel»

«DEFINE main FOR Application-»
«EXPAND database FOR dataHandler.databaseHandler-»
«EXPAND databaseStrings FOR dataHandler.databaseHandler-»
«ENDDEFINE-»

«DEFINE database FOR DatabaseHandler-»
«REM» DBHelper Class «ENDREM»
«FILE dataHandler.application.name+"/mobile/src/main/java/"+dataHandler.application.companyIdentifier.replaceAll("\\.","/") +"/"+dataHandler.application.name.toLowerCase() +"/data/DBHelper.java"-»
package «dataHandler.application.companyIdentifier».«dataHandler.application.name.toLowerCase()».data;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class DBHelper extends SQLiteOpenHelper{
	
	// If you change the database schema, you must increment the database version.
    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = "SQLITE_DB";
    
	public DBHelper(Context context){
		super(context, DATABASE_NAME, null, DATABASE_VERSION);
	}
	
	@Override
	public void onCreate(SQLiteDatabase db) {
		«EXPAND dbCreateQuery FOREACH entities-»
    }
    
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    	Log.w(MySQLiteHelper.class.getName(), "Upgrading database from version " + oldVersion + " to " + newVersion + ", which will destroy all old data");
        «EXPAND dbDeleteQuery FOREACH entities-»
        onCreate(db);
    }
}
«ENDFILE-»
«REM» DatabaseHandler Class «ENDREM»
«FILE dataHandler.application.name+"/mobile/src/main/java/"+dataHandler.application.companyIdentifier.replaceAll("\\.","/") +"/"+dataHandler.application.name.toLowerCase() +"/data/DatabaseHandler.java"-»
package «dataHandler.application.companyIdentifier».«dataHandler.application.name.toLowerCase()».data;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;

public class DatabaseHandler{
	
	private DBHelper dbhelper;
 
    public DatabaseHandler(Context context) 
    {
        dbhelper=new DBHelper(context);
    }
    
    «EXPAND save FOREACH entities-»
    «EXPAND delete FOREACH entities-»
    «EXPAND query FOREACH entities-»
}
«ENDFILE-»
«ENDDEFINE-»

«DEFINE databaseStrings FOR DatabaseHandler-»
«REM» DatabaseStrings Class «ENDREM»
«FILE dataHandler.application.name+"/mobile/src/main/java/"+dataHandler.application.companyIdentifier.replaceAll("\\.","/") +"/"+dataHandler.application.name.toLowerCase() +"/data/DatabaseStrings.java"-»
package «dataHandler.application.companyIdentifier».«dataHandler.application.name.toLowerCase()».data;

public class DatabaseStrings{

	«EXPAND entityStrings FOREACH entities-»
}
«ENDFILE-»
«ENDDEFINE-»

«REM» for each entity strings representing name and attributes «ENDREM»
«DEFINE entityStrings FOR Entity-»
	/* Strings for table «name»*/
	public static final String TBL_«name.toUpperCase()» = "«name»";
	public static final String «name.toUpperCase()»_ID = "«primaryKey»";
	«EXPAND attributeString FOREACH entityAttributes-»
	
«ENDDEFINE-»
«REM» for each entity the string query that creates the table «ENDREM»
«DEFINE dbCreateQuery FOR Entity-»

	String CREATE_«name.toUpperCase()»="CREATE TABLE "+DatabaseStrings.TBL_«name.toUpperCase()»+
                " (" + DatabaseStrings.«name.toUpperCase()»_ID + " INTEGER PRIMARY KEY," +
                
                «IF entityRelationships.isEmpty-»
	                «EXPAND attListCreate FOR entityAttributes.withoutLast()-»
	                «EXPAND attributeCreateLast FOR entityAttributes.last()-»
                «ELSE-»
	                «IF entityRelationships.exists(e|e.type.matches("N : N"))-»
	                «ENDIF-» 	
	                «IF entityRelationships.exists(e|e.type.matches("N : 1"))-»
	                	«IF entityRelationships.exists(e|e.type.matches("1 : 1"))-»
	                		«EXPAND attListCreate FOR entityAttributes-»
	                		«EXPAND foreignKeyOneOne FOR entityRelationships-»
	                		«EXPAND foreignKeyLastNOne FOR entityRelationships-»
	                	«ELSE-»
	                		«EXPAND foreignKeyLastNOne FOR entityRelationships-»
	                	«ENDIF-»
	                «ELSE-»
	                	«IF entityRelationships.exists(e|e.type.matches("1 : 1"))-»
	                		«EXPAND attListCreate FOR entityAttributes-»
	                		«EXPAND foreignKeyLastOneOne FOR entityRelationships-»
	                	«ENDIF-»
	                «ENDIF-»	          
               «ENDIF-»
            
  	db.execSQL(CREATE_«name.toUpperCase()»);
«ENDDEFINE-»
«REM» for each entity the string query that drops the table «ENDREM»
«DEFINE dbDeleteQuery FOR Entity-»
  	db.execSQL("DROP TABLE IF EXISTS " + DatabaseStrings.TBL_«name.toUpperCase()»);
«ENDDEFINE-»
«REM» for each entity the insert method «ENDREM»
«DEFINE save FOR Entity-»
public void insert«name.toFirstUpper()»(«EXPAND parameters FOR entityAttributes-»)
{
    SQLiteDatabase db=dbhelper.getWritableDatabase();
 
    ContentValues cv=new ContentValues();
    «EXPAND fieldPut FOREACH entityAttributes-»
    try
    {
        db.insert(DatabaseStrings.TBL_«name.toUpperCase()», null,cv);
    }
    catch (SQLiteException sqle)
    {
        
    }
}
«ENDDEFINE-»

«REM» parameters for insert method «ENDREM»
«DEFINE parameters FOR List[EntityAttribute]-»
«FOREACH this.withoutLast() AS EA-»
«IF EA.type.matches('String') || EA.type.matches('Date') -»
String «EA.name»,
«ENDIF-»
«IF EA.type.matches('Integer')-»
int «EA.name»,
«ENDIF-»
«IF EA.type.matches('Boolean')-»
boolean «EA.name»,
«ENDIF-»
«IF EA.type.matches('Float')-»
float «EA.name»,
«ENDIF-»
«IF EA.type.matches('Double')-»
double «EA.name»,
«ENDIF-»
«ENDFOREACH-»
«EXPAND lastParameter FOR (EntityAttribute)this.last()-»
«ENDDEFINE-»

«REM» last parameter for insert method (without COMMA) «ENDREM»
«DEFINE lastParameter FOR EntityAttribute-»
«IF type.matches('String') || type.matches('Date') -»
String «name»
«ENDIF-»
«IF type.matches('Integer')-»
int «name»
«ENDIF-»
«IF type.matches('Boolean')-»
boolean «name»
«ENDIF-»
«IF type.matches('Float') || type.matches('Double')-»
float «name»
«ENDIF-»
«ENDDEFINE-»

«REM» delete method for each entity «ENDREM»
«DEFINE delete FOR Entity-»
public boolean delete«name.toFirstUpper()»(String «primaryKey»)
{
    SQLiteDatabase db=dbhelper.getWritableDatabase();
    try
    {
        if (db.delete(DatabaseStrings.TBL_«name.toUpperCase()», DatabaseStrings.«name.toUpperCase()»_ID+"=?", new String[]{«primaryKey»})>0)
            return true;
        return false;
    }
    catch (SQLiteException sqle)
    {
        return false;
    } 
}
«ENDDEFINE-»

«REM» query method for each entity «ENDREM»
«DEFINE query FOR Entity-»
// edit for creating a personalized query
public Cursor query«name.toFirstUpper()»()
{
    Cursor crs=null;
    String tableName = DatabaseStrings.TBL_«name.toUpperCase()»;
    String[] tableColumns = null; //new String[] { DatabaseStrings.«name.toUpperCase()»_«entityAttributes.get(0).name.toUpperCase()», ... }
    String whereClause = null; // DatabaseStrings.«name.toUpperCase()»_«entityAttributes.get(0).name.toUpperCase()» + " > 5"
    String whereArgs = null; // new String[] { "value1", "value2"};
    String groupBy = null;
    String having = null;
    String orderBy = null;
    try
    {
        SQLiteDatabase db=dbhelper.getReadableDatabase();
        crs=db.query(tableName, tableColumns, whereClause, whereArgs, groupBy, having, orderBy);
        // For quering with a complete SQL string
        // String whereArgs = new String[] { "value1", "value2"};
        // String SQL_QUERY = "SELECT column1, (SELECT max(column1) FROM DatabaseStrings.TBL_«name.toUpperCase()») AS max FROM DatabaseStrings.TBL_«name.toUpperCase()» " + "WHERE column1 = ? OR column1 = ? ORDER BY column1";
        //crs=db.rawQuery(SQL_QUERY, whereArgs);
    }
    catch(SQLiteException sqle)
    {
        return null;
    }
    /*	EXAMPLE USAGE
    	crs.moveToFirst();
        while (crs.isAfterLast() == false) {
            String value = crs.getString(1)
       	    crs.moveToNext();
        }
        crs.close(); 
    */
    return crs;
}
«ENDDEFINE-»

«DEFINE attributeString FOR EntityAttribute-»
public static final String «entity.name.toUpperCase()»_«name.toUpperCase()» = "«name»";
«ENDDEFINE-»

«DEFINE fieldPut FOR EntityAttribute-»
cv.put(DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()», «name»);
«ENDDEFINE-»

«DEFINE attListCreate FOR List[EntityAttribute]-»
«FOREACH this AS EA-»
«IF EA.type.matches('String') || EA.type.matches('Date') -»
DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()»+" TEXT," +
«ENDIF-»
«IF EA.type.matches('Integer') || EA.type.matches('Boolean')-»
DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()»+" INT," +
«ENDIF-»
«IF EA.type.matches('Float') || EA.type.matches('Double')-»
DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()»+" REAL," +
«ENDIF-»
«ENDFOREACH-»
«ENDDEFINE-»

«DEFINE foreignKeyOneOne FOR List[EntityRelationship]-»
«FOREACH this AS ER-»
«IF ER.type.matches("N : N") || ER.type.matches("1 : N") || ER.type.matches("N : 1")-»
«this.remove(ER)-»
«ENDIF-»
«ENDFOREACH-»
«FOREACH this AS ER-»
+ " FOREIGN KEY ("+DatabaseStrings.«ER.destination.toUpperCase()-»_ID+") REFERENCES "+DatabaseStrings.TBL_«ER.destination.toUpperCase()-»+"("+«ER.destination.toUpperCase()-»_ID," +
«ENDFOREACH-»
«ENDDEFINE-»

«DEFINE foreignKeyNOne FOR List[EntityRelationship]-»
«FOREACH this AS ER-»
«IF ER.type.matches("N : N") || ER.type.matches("1 : N") || ER.type.matches("1 : 1")-»
«this.remove(ER)-»
«ENDIF-»
«ENDFOREACH-»
«FOREACH this AS ER-»
+ " FOREIGN KEY ("+DatabaseStrings.«ER.destination.toUpperCase()-»_ID+") REFERENCES "+DatabaseStrings.TBL_«ER.destination.toUpperCase()-»+"("+«ER.destination.toUpperCase()-»_ID," +
«ENDFOREACH-»
«ENDDEFINE-»

«DEFINE foreignKeyLastOneOne FOR List[EntityRelationship]-»
«FOREACH this AS ER-»
«IF ER.type.matches("N : N") || ER.type.matches("1 : N") || ER.type.matches("N : 1")-»
«this.remove(ER)-»
«ENDIF-»
«ENDFOREACH-»
«FOREACH this.withoutLast() AS ER-»
+ " FOREIGN KEY ("+DatabaseStrings.«ER.destination.toUpperCase()-»_ID+") REFERENCES "+DatabaseStrings.TBL_«ER.destination.toUpperCase()-»+"("+«ER.destination.toUpperCase()-»_ID," +
«ENDFOREACH-»
+ " FOREIGN KEY ("+DatabaseStrings.«this.last().destination.toUpperCase()-»_ID+") REFERENCES "+DatabaseStrings.TBL_«this.last().destination.toUpperCase()-»+"("+«this.last().destination.toUpperCase()-»_ID+"));";
«ENDDEFINE-»

«DEFINE foreignKeyLastNOne FOR List[EntityRelationship]-»
«FOREACH this AS ER-»
«IF ER.type.matches("1 : 1") || ER.type.matches("1 : N") || ER.type.matches("N : N") -»
«this.remove(ER)-»
«ENDIF-»
«ENDFOREACH-»
«FOREACH this.withoutLast() AS ER-»
+ " FOREIGN KEY ("+DatabaseStrings.«ER.destination.toUpperCase()-»_ID+") REFERENCES "+DatabaseStrings.TBL_«ER.destination.toUpperCase()-»+"("+«ER.destination.toUpperCase()-»_ID," +
«ENDFOREACH-»
+ " FOREIGN KEY ("+DatabaseStrings.«this.last().destination.toUpperCase()-»_ID+") REFERENCES "+DatabaseStrings.TBL_«this.last().destination.toUpperCase()-»+"("+«this.last().destination.toUpperCase()-»_ID+"));";
«ENDDEFINE-»

«DEFINE attributeCreateLast FOR EntityAttribute-»
«IF type.matches('String') || type.matches('Date') -»
DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()»+" TEXT)";
«ENDIF-»
«IF type.matches('Integer') || type.matches('Boolean')-»
DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()»+" INT)";
«ENDIF-»
«IF type.matches('Float') || type.matches('Double')-»
DatabaseStrings.«entity.name.toUpperCase()»_«name.toUpperCase()»+" REAL)";
«ENDIF-»
«ENDDEFINE-»

